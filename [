#include <chrono>
#include <random>
#include <tuple>
#include <type_traits>

#include "branch_miss.h"
#include "llvm/Analysis/BranchProbabilityInfo.h"

using namespace llvm;

inline float getRand() noexcept {
  std::uniform_real_distribution<float>  Distribution(0.0, 1.0);
  std::default_random_engine Generator(std::chrono::system_clock::now().time_since_epoch().count());
  return Distribution(Generator);
}

BlockType MCPredictionMissRate::isTerminatingBlock(const BasicBlock& bb, const BasicBlock& front) noexcept {
  if(successors(&bb).empty()) {
    // If the function only has a single basic block, then simply return false. We don't care about it
    if(&bb == &front) {
      errs() << "No usable basic blocks in function.\n";
      return BlockType::EMPTY;
      // else if current block isn't the first block, it's a regular terminating block. Increase the looop count and go back to the start of the function
    } else { 
      return BlockType::TERM;
    }
  }
  return BlockType::NORM;
}

float MCPredictionMissRate::getMissRate(const BasicBlock& bb) noexcept {
  float res{};
  for(auto j : successors(&bb)) {
    // Index into probability for a given pair of blocks is &B1 XOR &B2
    auto key = reinterpret_cast<uint64_t>(&bb) ^ reinterpret_cast<uint64_t>(j);
    auto br = probabilityTable.find(key);
    if(br->second.hits == br->second.hits + br->second.misses) {
      continue;
    }
    res += static_cast<double>(br->second.prob_prev *    /* Pbb(i) */
                              br->second.prob_cur *     /* Î (i)(j) */
                              /* Pmis-predict(i)(j) */
                              (static_cast<double>(br->second.misses) / static_cast<double>(br->second.misses + br->second.hits)));   
  }
  return res;
}

std::tuple<const BasicBlock*, uint32_t> getSuccessor(const BasicBlock* bb, BranchProbabilityInfo* bp) noexcept {
  auto start = 0.0f;
  auto count = 0;
  auto rand = getRand();
  // Use that random number to select a successor "Actual"
  for(auto succ : successors(bb)) {
    auto edgeProbs = bp->getEdgeProbability(bb, succ);
    float end = start + static_cast<float>(edgeProbs.getNumerator()) / (edgeProbs.getDenominator());
    if(rand >= start && rand < end) {
      return std::make_tuple(succ, count);
    }
    count++;
    start = end;
  }
  return std::make_tuple(nullptr, count);
}

bool MCPredictionMissRate::runOnFunction(Function &F) {

  const auto &Blocks = F.getBasicBlockList();
  int loop_count{};
  auto cur = &Blocks.front();
  BasicBlock *prev = const_cast<BasicBlock*>(cur);

  while(loop_count < tests) {
    Correlation pred{};
    // check if it's a terminating block
    auto tb = isTerminatingBlock(*cur, Blocks.front());
    if(tb == BlockType::EMPTY){
      return false;
    } else if(tb == BlockType::TERM) {
      loop_count++;
      cur = &Blocks.front();
      continue;
    }

    auto prob = BranchProbabilityInfo();

    errs() << "gets here\n";
    auto [next, count] = getSuccessor(cur, &prob);
    
    auto res = pred.predict(cur, count);
    // update the map of cur -> successor branch info
    for(auto succ : successors(cur)) {
      // Get the current branch to successor probability
      auto edgeProbsCur = prob.getEdgeProbability(cur, succ);
      auto p = static_cast<float>(edgeProbsCur.getNumerator()) / (edgeProbsCur.getDenominator());
      // Get the previous branch to current probability
      auto edgeProbsPrev = prob.getEdgeProbability(prev, cur);
      auto pp = static_cast<float>(edgeProbsPrev.getNumerator()) / (edgeProbsPrev.getDenominator());

      auto key = reinterpret_cast<uint64_t>(cur) ^ reinterpret_cast<uint64_t>(succ);
      auto tmp = ps();
      
      tmp.prob_cur = p;
      if(pp == 0) pp = 1;
      tmp.prob_prev = pp;

      auto ps_found = probabilityTable.find(key);     
      if(ps_found == probabilityTable.end()) {
        probabilityTable.insert(std::make_pair(key, tmp));
        break;
      }
      auto ps = probabilityTable.find(key);
      ps->second.n_arrives++;
      if(next == succ && res) {
        ps->second.hits++;
      } else if (next != succ && !res) {
        ps->second.misses++;
      }

    }
    prev = const_cast<BasicBlock*>(cur);
    cur = next;
  }
  auto res = 0.0;
  for(auto &i : Blocks) {
    res += getMissRate(i);
  }
  errs() << "Miss Rate (%) : " << (res) << "\n";

  return false;
}


char MCPredictionMissRate::ID = 0;
static RegisterPass<MCPredictionMissRate> X("mc-branch-miss", "Monte-Carlo branch prediction miss rate simulation",
                             false /* Only looks at CFG */,
                             false /* Analysis Pass */);
